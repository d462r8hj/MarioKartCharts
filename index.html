<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mario Kart 8 Deluxe Turnier</title>
  <style>
    :root {
      --bg-1: #050712;
      --bg-2: #10153a;
      --card: #ffffff;
      --ink: #14172b;
      --muted: #5f6893;
      --line: #dbe2ff;
      --blue-1: #1f35b8;
      --blue-2: #2f57ff;
      --blue-3: #00b7ff;
      --violet-1: #6a39ff;
      --violet-2: #8c4dff;
      --violet-3: #b17bff;
      --shadow: 0 16px 40px rgba(2, 8, 26, 0.45);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--ink);
      font-family: "Trebuchet MS", "Verdana", sans-serif;
      background:
        radial-gradient(circle at 10% 15%, rgba(47, 87, 255, 0.26), transparent 28%),
        radial-gradient(circle at 88% 8%, rgba(140, 77, 255, 0.24), transparent 28%),
        radial-gradient(circle at 78% 90%, rgba(0, 183, 255, 0.22), transparent 30%),
        linear-gradient(160deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.07;
      background-image:
        linear-gradient(45deg, #fff 25%, transparent 25%),
        linear-gradient(-45deg, #fff 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #fff 75%),
        linear-gradient(-45deg, transparent 75%, #fff 75%);
      background-size: 22px 22px;
      background-position: 0 0, 0 11px, 11px -11px, -11px 0;
      z-index: 0;
    }

    .wrap {
      width: min(1220px, 94vw);
      margin: 24px auto 34px;
      display: grid;
      gap: 16px;
      position: relative;
      z-index: 1;
    }

    .content-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
      align-items: start;
    }

    .hero {
      border-radius: 18px;
      padding: 24px 22px;
      color: #fff;
      box-shadow: var(--shadow);
      background: linear-gradient(120deg, rgba(0, 183, 255, 0.9), rgba(47, 87, 255, 0.92) 42%, rgba(140, 77, 255, 0.92));
      border: 2px solid rgba(255, 255, 255, 0.24);
      position: relative;
      overflow: hidden;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.14), transparent);
      transform: skewX(-18deg) translateX(-120%);
      animation: shine 6s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes shine {
      0% { transform: skewX(-18deg) translateX(-120%); }
      45% { transform: skewX(-18deg) translateX(120%); }
      100% { transform: skewX(-18deg) translateX(120%); }
    }

    .hero h1 {
      margin: 0;
      font-size: clamp(1.6rem, 2.7vw, 2.3rem);
      line-height: 1.1;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.35);
    }

    .countdown {
      margin-top: 10px;
      display: inline-block;
      padding: 7px 11px;
      border-radius: 10px;
      background: rgba(10, 22, 77, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.35);
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .hero-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .game-switch {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      overflow: hidden;
      background: rgba(10, 22, 77, 0.35);
    }

    .game-btn {
      border: 0;
      background: transparent;
      color: #fff;
      font-weight: 700;
      font-size: 0.82rem;
      padding: 7px 11px;
      cursor: pointer;
      letter-spacing: 0.2px;
    }

    .game-btn[aria-pressed="true"] {
      background: rgba(255, 255, 255, 0.24);
    }

    .card {
      background: var(--card);
      border: 2px solid #dbe4ff;
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .section-head {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      border-bottom: 1px solid var(--line);
      background: #f4f7ff;
    }

    .section-head h2 {
      margin: 0;
      font-size: 1.03rem;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }

    .meta { font-size: 0.9rem; color: var(--muted); }

    .controls {
      padding: 12px 16px 14px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(135deg, rgba(47, 87, 255, 0.09), rgba(140, 77, 255, 0.12));
      display: grid;
      gap: 8px;
    }

    .controls label {
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      color: #253061;
    }

    .slider-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .select-row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: center;
      max-width: 280px;
    }

    .select-row label {
      margin: 0;
      font-size: 0.8rem;
    }

    .select-row select {
      border: 1px solid #bbc8ff;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 0.86rem;
      background: #fff;
      color: #24326f;
    }

    input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--blue-2); }

    .pill {
      border-radius: 999px;
      padding: 6px 11px;
      background: linear-gradient(120deg, var(--blue-1), var(--violet-1));
      color: #fff;
      font-weight: 700;
      font-size: 0.84rem;
      white-space: nowrap;
    }

    .table-wrap { overflow-x: auto; padding: 8px 10px 14px; }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 760px;
      font-size: 0.92rem;
      background: #fff;
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      text-align: left;
      padding: 9px 10px;
      color: #fff;
      background: #2538bd;
      border-bottom: 2px solid #1a2d9f;
    }

    tbody td {
      padding: 8px 10px;
      border-bottom: 1px solid #e6edff;
      vertical-align: middle;
    }

    tbody tr:nth-child(odd) { background: #f8faff; }
    tbody tr:hover { background: #edf4ff; }

    .num { text-align: right; font-variant-numeric: tabular-nums; }
    .rank { font-weight: 800; color: #132b96; }
    .delta-up { color: #1d9f55; font-weight: 800; }
    .delta-down { color: #cf3b3b; font-weight: 800; }
    .delta-flat { color: #b08c00; font-weight: 800; }

    .player {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid #b17bff;
      box-shadow: 0 0 0 2px #1243d2;
      object-fit: cover;
      background: #fff;
      flex: 0 0 auto;
    }

    .charts {
      display: grid;
      gap: 14px;
      padding: 12px;
      grid-template-columns: 1fr;
    }

    .chart-card {
      border: 1px solid #dbe4ff;
      border-radius: 12px;
      padding: 10px;
      background: linear-gradient(180deg, #ffffff, #f7faff);
    }

    .chart-card.full {
      background:
        linear-gradient(180deg, #ffffff, #f7faff),
        repeating-linear-gradient(45deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.02) 6px, transparent 6px, transparent 12px);
    }

    .chart-card h3 {
      margin: 4px 4px 9px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: #253061;
    }

    .chart-svg { width: 100%; height: auto; display: block; }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 4px 3px;
      font-size: 0.8rem;
      color: #30427e;
    }

    .legend-item { display: inline-flex; align-items: center; gap: 5px; cursor: pointer; }
    .legend-dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; }
    .player-meta { color: #5f6b96; }

    .line-tooltip {
      position: fixed;
      pointer-events: none;
      z-index: 20;
      background: rgba(18, 27, 73, 0.96);
      color: #fff;
      border: 1px solid rgba(177, 123, 255, 0.8);
      border-radius: 10px;
      padding: 8px 10px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.84rem;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.28);
      transform: translate(10px, 10px);
    }

    .line-tooltip[hidden] { display: none; }

    .line-tooltip img {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid #b17bff;
      background: #fff;
    }

    .error {
      margin: 10px 14px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #f2a5a5;
      background: #fff2f2;
      color: #a32929;
      font-size: 0.9rem;
    }

    body.game-mkworld {
      background:
        radial-gradient(circle at 12% 10%, rgba(0, 240, 214, 0.26), transparent 26%),
        radial-gradient(circle at 88% 12%, rgba(45, 150, 255, 0.28), transparent 30%),
        radial-gradient(circle at 72% 86%, rgba(125, 232, 255, 0.2), transparent 32%),
        linear-gradient(155deg, #02141f, #0a3554 55%, #0a2a40);
    }

    body.game-mkworld .hero {
      border-radius: 24px;
      border: 1px solid rgba(173, 246, 255, 0.55);
      background:
        linear-gradient(110deg, rgba(0, 167, 209, 0.9), rgba(26, 97, 255, 0.9) 48%, rgba(84, 226, 255, 0.85)),
        radial-gradient(circle at 84% -15%, rgba(255, 255, 255, 0.45), transparent 48%);
      box-shadow: 0 18px 46px rgba(2, 13, 29, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.22);
    }

    body.game-mkworld .hero::before {
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.22), transparent);
      animation-duration: 5.4s;
    }

    body.game-mkworld .hero h1 {
      letter-spacing: 0.8px;
      text-shadow: 0 5px 14px rgba(0, 18, 38, 0.45);
    }

    body.game-mkworld .countdown {
      background: rgba(2, 35, 71, 0.44);
      border-color: rgba(186, 248, 255, 0.72);
    }

    body.game-mkworld .game-switch {
      background: rgba(6, 35, 72, 0.34);
      border-color: rgba(162, 238, 255, 0.58);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
    }

    body.game-mkworld .game-btn {
      padding: 8px 13px;
      letter-spacing: 0.45px;
      font-weight: 800;
    }

    body.game-mkworld .game-btn[aria-pressed="true"] {
      background: linear-gradient(120deg, rgba(116, 244, 255, 0.34), rgba(71, 155, 255, 0.44));
      text-shadow: 0 0 8px rgba(177, 250, 255, 0.55);
    }

    body.game-mkworld .card {
      border-radius: 18px;
      border: 1px solid rgba(161, 241, 255, 0.46);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.93), rgba(236, 249, 255, 0.9));
      backdrop-filter: blur(9px);
      box-shadow: 0 15px 38px rgba(1, 16, 34, 0.34);
    }

    body.game-mkworld .section-head {
      background: linear-gradient(90deg, rgba(9, 74, 133, 0.9), rgba(9, 119, 180, 0.88));
      border-bottom-color: rgba(164, 240, 255, 0.48);
      color: #e9fbff;
    }

    body.game-mkworld .section-head h2 {
      color: #f4feff;
      text-shadow: 0 2px 8px rgba(0, 24, 46, 0.35);
    }

    body.game-mkworld .section-head .meta {
      color: #d8f6ff;
    }

    body.game-mkworld .controls {
      background: linear-gradient(132deg, rgba(34, 137, 221, 0.13), rgba(0, 200, 180, 0.15));
      border-bottom-color: rgba(140, 225, 246, 0.45);
    }

    body.game-mkworld .controls label {
      color: #0f5d88;
    }

    body.game-mkworld .select-row select {
      border-color: rgba(87, 191, 236, 0.75);
      color: #0d5278;
      background: linear-gradient(180deg, #ffffff, #ebfaff);
    }

    body.game-mkworld .controls {
      background: linear-gradient(135deg, rgba(0, 120, 255, 0.1), rgba(0, 196, 167, 0.12));
    }

    body.game-mkworld .pill {
      background: linear-gradient(120deg, #0078ff, #00c4a7);
    }

    body.game-mkworld thead th {
      background: linear-gradient(90deg, #0d79d1, #2a9fe3);
      border-bottom-color: #0a6dc2;
      text-shadow: 0 2px 8px rgba(0, 32, 61, 0.35);
    }

    body.game-mkworld .rank { color: #0063d2; }
    body.game-mkworld .delta-up { color: #1d9f55; }
    body.game-mkworld .delta-down { color: #cf3b3b; }
    body.game-mkworld .delta-flat { color: #b08c00; }

    body.game-mkworld tbody tr:nth-child(odd) { background: #f2faff; }
    body.game-mkworld tbody tr:hover { background: #e4f5ff; }

    body.game-mkworld .chart-card {
      border-color: rgba(117, 205, 239, 0.5);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.92), rgba(240, 252, 255, 0.9)),
        repeating-linear-gradient(45deg, rgba(44, 138, 198, 0.03), rgba(44, 138, 198, 0.03) 7px, transparent 7px, transparent 14px);
    }

    body.game-mkworld .chart-card h3 { color: #0f5d88; }
    body.game-mkworld .legend { color: #126087; }
    body.game-mkworld .legend-dot { box-shadow: 0 0 0 1px rgba(13, 81, 121, 0.22); }

    @media (min-width: 860px) {
      .content-grid {
        grid-template-columns: minmax(420px, 0.9fr) minmax(520px, 1.1fr);
      }

      .content-grid > .card:first-child table {
        min-width: 0;
        width: 100%;
        table-layout: fixed;
        font-size: 0.86rem;
      }

      .content-grid > .card:first-child thead th,
      .content-grid > .card:first-child tbody td {
        padding: 6px 6px;
      }

      .content-grid > .card:first-child th:nth-child(1),
      .content-grid > .card:first-child td:nth-child(1) {
        width: 8%;
        text-align: center;
      }

      .content-grid > .card:first-child th:nth-child(2),
      .content-grid > .card:first-child td:nth-child(2) {
        width: 36%;
      }

      .content-grid > .card:first-child th:nth-child(3),
      .content-grid > .card:first-child td:nth-child(3),
      .content-grid > .card:first-child th:nth-child(4),
      .content-grid > .card:first-child td:nth-child(4),
      .content-grid > .card:first-child th:nth-child(5),
      .content-grid > .card:first-child td:nth-child(5) {
        width: 18.666%;
        white-space: nowrap;
      }

      .content-grid > .card:first-child .player > div > div {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    }

    @media (min-width: 980px) {
      .charts { grid-template-columns: 1.5fr 1fr; }
      .chart-card.full { grid-column: 1 / -1; }
    }

    @media (max-width: 480px) {
      .wrap { width: 96vw; margin: 12px auto 20px; gap: 12px; }
      .hero { padding: 14px 14px; }
      .hero h1 { font-size: 1.15rem; }
      .game-btn { font-size: 0.75rem; padding: 6px 8px; }
      .countdown { font-size: 0.76rem; padding: 6px 8px; }
      .section-head { padding: 10px 12px; }
      .section-head h2 { font-size: 0.9rem; }
      .meta { font-size: 0.77rem; }
      .controls { padding: 10px 12px 12px; }
      .controls label { font-size: 0.76rem; }
      .select-row { max-width: 220px; }
      .pill { font-size: 0.76rem; padding: 4px 8px; }
      .table-wrap { padding: 6px 0 10px; overflow-x: hidden; }
      table { min-width: 0; width: 100%; table-layout: fixed; font-size: 0.74rem; }
      thead th, tbody td { padding: 5px 4px; }
      .avatar { width: 28px; height: 28px; border-width: 1px; box-shadow: 0 0 0 1px #1243d2; }
      .player { gap: 7px; }
      .player > div > div { display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 13ch; }
      .player-meta {
        display: block;
        font-size: 0.68rem;
        line-height: 1.1;
        opacity: 0.9;
      }
      th:nth-child(1), td:nth-child(1) {
        text-align: center;
        width: 9%;
        min-width: 28px;
        white-space: nowrap;
        padding-left: 2px;
        padding-right: 2px;
      }
      th:nth-child(2), td:nth-child(2) { width: 32%; white-space: nowrap; }
      th:nth-child(3), td:nth-child(3),
      th:nth-child(4), td:nth-child(4),
      th:nth-child(5), td:nth-child(5) { width: 19%; white-space: nowrap; }
    }
  </style>
</head>
<body class="game-mk8d">
  <main class="wrap">
    <section class="hero">
      <div class="hero-top">
        <h1 id="heroTitle">Mario Kart 8 Deluxe Turnier Dashboard</h1>
        <div class="game-switch" role="tablist" aria-label="Spiel ausw√§hlen">
          <button id="gameMk8dBtn" class="game-btn" type="button" aria-pressed="true">MK8 Deluxe</button>
          <button id="gameMkworldBtn" class="game-btn" type="button" aria-pressed="false">Mario Kart World</button>
        </div>
      </div>
      <div id="countdownBanner" class="countdown">N√§chstes Turnier wird berechnet...</div>
    </section>

    <div class="content-grid">
      <section class="card">
        <div class="section-head">
          <h2>Rangliste</h2>
          <div class="meta" id="dataMeta">Lade Daten...</div>
        </div>
        <div class="controls">
          <div class="select-row">
            <label for="yearSelect">Jahr</label>
            <select id="yearSelect" disabled>
              <option>2026</option>
            </select>
          </div>
          <label for="weekSlider">Woche ausw√§hlen</label>
          <div class="slider-row">
            <input id="weekSlider" type="range" min="0" max="0" value="0" />
            <span id="weekLabel" class="pill">Woche 1</span>
          </div>
        </div>
        <div id="error" class="error" hidden></div>
        <div class="table-wrap">
          <table aria-label="Mario Kart Rangliste">
            <thead>
              <tr>
                <th>#</th>
                <th title="Name">üèéÔ∏è</th>
                <th class="num" title="Woche">üìÖ</th>
                <th class="num" title="Gesamt">üóìÔ∏è</th>
                <th class="num" title="Delta">‚ÜïÔ∏è</th>
              </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>
      </section>

      <section class="card">
        <div class="section-head">
          <h2>Diagramme</h2>
          <div class="meta">Nur Wochen mit vorhandenen Daten</div>
        </div>
        <div class="charts">
          <article class="chart-card full">
            <h3>Platzierungsverlauf je Spieler</h3>
            <svg id="positionsChart" class="chart-svg" viewBox="0 0 1080 420" role="img" aria-label="Platzierungsverlauf"></svg>
            <div id="lineLegend" class="legend"></div>
          </article>
          <article class="chart-card">
            <h3>Kumulierte Punkte</h3>
            <svg id="pointsChart" class="chart-svg" viewBox="0 0 520 360" role="img" aria-label="Kumulierte Punkte"></svg>
          </article>
          <article class="chart-card">
            <h3>Momentum (letzte 3 Datenwochen)</h3>
            <svg id="momentumChart" class="chart-svg" viewBox="0 0 520 360" role="img" aria-label="Momentum"></svg>
          </article>
        </div>
      </section>
    </div>
  </main>

  <div id="lineTooltip" class="line-tooltip" hidden>
    <img id="lineTooltipImg" src="https://via.placeholder.com/72/ffffff/2243c7?text=MK" alt="" />
    <span id="lineTooltipName"></span>
  </div>

  <script>
    const CONFIG = {
      playersCsvFile: "spieler.csv",
      tournamentsCsvFile: "turniere.csv"
    };

    const GAME_CONFIG = {
      mk8d: {
        label: "Mario Kart 8 Deluxe",
        bodyClass: "game-mk8d",
        title: "Mario Kart 8 Deluxe Turnier Dashboard",
        weekday: 3,
        startHour: 20,
        startMinute: 30,
        endHour: 22,
        endMinute: 0
      },
      mkworld: {
        label: "Mario Kart World",
        bodyClass: "game-mkworld",
        title: "Mario Kart World Turnier Dashboard",
        weekday: 7,
        startHour: 20,
        startMinute: 0,
        endHour: 22,
        endMinute: 0
      }
    };

    const CHARACTER_META = {
      "mario": { page: "Mario", color: "#e52521", faceAnchor: "upper"  },
      "luigi": { page: "Luigi", color: "#43b047", faceAnchor: "upper" },
      "peach": { page: "Princess Peach", color: "#ff84b7", faceAnchor: "upper"  },
      "daisy": { page: "Princess Daisy", color: "#f8a100" },
      "rosalina": { page: "Rosalina", color: "#6dd3ff", faceAnchor: "upper"  },
      "toad": { page: "Toad", color: "#2f57ff" },
      "yoshi": { page: "Yoshi", color: "#4caf50", faceAnchor: "upper"  },
      "bowser": { page: "Bowser", color: "#8acb45" },
      "bowser jr": { page: "Bowser Jr.", color: "#76c043", faceAnchor: "center" },
      "donkey kong": { page: "Donkey Kong", color: "#8d6e63" },
      "diddy kong": { page: "Diddy Kong", color: "#ff5252" },
      "koopa troopa": { page: "Koopa Troopa", color: "#71c568" },
      "wario": { page: "Wario", color: "#f4c20d" , faceAnchor: "upper" },
      "waluigi": { page: "Waluigi", color: "#7a3cff", faceAnchor: "upper"  },
      "king boo": { page: "King Boo", color: "#b3b8d1" },
      "dry bones": { page: "Dry Bones", color: "#9ea7c9" },
      "tanuki mario": { page: "Tanooki Mario", color: "#b8793a", faceAnchor: "upper"  },
      "tanooki mario": { page: "Tanooki Mario", color: "#b8793a", faceAnchor: "upper" },
      "katzen mario": { page: "Cat Mario", color: "#f7c948" },
      "cat mario": { page: "Cat Mario", color: "#f7c948" },
      "black yoshi": { page: "Yoshi", color: "#2f2f2f", faceAnchor: "upper" },
      "knochenbowser": { page: "Dry Bowser", color: "#9ea7c9", faceAnchor: "upper"  },
      "knochen bowser": { page: "Dry Bowser", color: "#9ea7c9", faceAnchor: "upper"  }
    };

    const COLOR_POOL = ["#2f57ff", "#6a39ff", "#00b7ff", "#8c4dff", "#3044c8", "#7a52ff", "#4f63ff", "#9a62ff"];
    const FALLBACK_AVATAR = "https://via.placeholder.com/72/ffffff/2243c7?text=MK";

    const state = {
      allPlayerRows: [],
      allTournamentRows: [],
      availableYears: [],
      selectedYear: null,
      selectedGame: "mk8d",
      availableGames: [],
      players: [],
      weekColumns: [],
      selectedWeekIndex: 0,
      avatarCache: new Map(),
      activePlayerId: null
    };

    const el = {
      slider: document.getElementById("weekSlider"),
      yearSelect: document.getElementById("yearSelect"),
      weekLabel: document.getElementById("weekLabel"),
      leaderboardBody: document.getElementById("leaderboardBody"),
      meta: document.getElementById("dataMeta"),
      error: document.getElementById("error"),
      positionsChart: document.getElementById("positionsChart"),
      pointsChart: document.getElementById("pointsChart"),
      momentumChart: document.getElementById("momentumChart"),
      lineLegend: document.getElementById("lineLegend"),
      lineTooltip: document.getElementById("lineTooltip"),
      lineTooltipImg: document.getElementById("lineTooltipImg"),
      lineTooltipName: document.getElementById("lineTooltipName"),
      countdownBanner: document.getElementById("countdownBanner"),
      heroTitle: document.getElementById("heroTitle"),
      gameMk8dBtn: document.getElementById("gameMk8dBtn"),
      gameMkworldBtn: document.getElementById("gameMkworldBtn")
    };

    function normalizeKey(value) { return String(value || "").trim().toLowerCase(); }
    function normalizeCharacter(value) { return normalizeKey(value).replace(/\./g, "").replace(/\s+/g, " "); }
    function faceObjectPosition(anchor) {
      if (anchor === "upper") return "50% 16%";
      if (anchor === "lower") return "50% 65%";
      return "50% 50%";
    }
    function normalizeGameKey(value) {
      const key = normalizeKey(value);
      if (!key) return "mk8d";
      if (key === "mk8" || key === "mk8d" || key === "mario kart 8" || key === "mario kart 8 deluxe") return "mk8d";
      if (key === "mkworld" || key === "mk world" || key === "mario kart world") return "mkworld";
      return key;
    }

    function toNumber(value) {
      const cleaned = String(value ?? "").trim().replace(",", ".");
      if (!cleaned) return 0;
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : 0;
    }

    function splitDelimitedLine(line, delim) {
      const cells = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < line.length; i += 1) {
        const ch = line[i];
        if (ch === "\"") {
          if (inQuotes && line[i + 1] === "\"") {
            cur += "\"";
            i += 1;
          } else {
            inQuotes = !inQuotes;
          }
          continue;
        }
        if (ch === delim && !inQuotes) {
          cells.push(cur);
          cur = "";
          continue;
        }
        cur += ch;
      }

      cells.push(cur);
      return cells;
    }

    function parseDelimited(text) {
      const rows = text.replace(/^\uFEFF/, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
      const lines = rows.filter((line) => line.trim().length > 0);
      if (!lines.length) return [];

      const semicolonCols = splitDelimitedLine(lines[0], ";").length;
      const commaCols = splitDelimitedLine(lines[0], ",").length;
      const delim = semicolonCols >= commaCols ? ";" : ",";

      const headers = splitDelimitedLine(lines[0], delim).map((h) => h.trim());
      return lines.slice(1).map((line) => {
        const cells = splitDelimitedLine(line, delim);
        const row = {};
        headers.forEach((h, i) => { row[h] = (cells[i] ?? "").trim(); });
        return row;
      });
    }

    function parseKw(value) {
      const match = String(value || "").match(/(\d+)/);
      return match ? Number(match[1]) : null;
    }

    function parseIsoWeekFromDate(dateValue) {
      const text = String(dateValue || "").trim();
      const m = text.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return null;
      return getISOWeek(new Date(y, mo - 1, d));
    }

    function parseYear(value) {
      const match = String(value || "").match(/(20\d{2})/);
      return match ? Number(match[1]) : null;
    }

    function addDaysUtc(y, m, d, days) {
      const dt = new Date(Date.UTC(y, m - 1, d + days));
      return { year: dt.getUTCFullYear(), month: dt.getUTCMonth() + 1, day: dt.getUTCDate() };
    }

    function getBerlinNowParts(date = new Date()) {
      const formatter = new Intl.DateTimeFormat("en-GB", {
        timeZone: "Europe/Berlin",
        weekday: "short",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      });
      const parts = Object.fromEntries(formatter.formatToParts(date).map((p) => [p.type, p.value]));
      const weekdayMap = { Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6, Sun: 7 };
      return {
        year: Number(parts.year),
        month: Number(parts.month),
        day: Number(parts.day),
        hour: Number(parts.hour),
        minute: Number(parts.minute),
        second: Number(parts.second),
        weekday: weekdayMap[parts.weekday] || 1
      };
    }

    function getTimeZoneOffsetMs(date, timeZone) {
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      });
      const p = Object.fromEntries(formatter.formatToParts(date).map((part) => [part.type, part.value]));
      const asUtc = Date.UTC(Number(p.year), Number(p.month) - 1, Number(p.day), Number(p.hour), Number(p.minute), Number(p.second));
      return asUtc - date.getTime();
    }

    function zonedDateTimeToUtcMs(year, month, day, hour, minute, second, timeZone) {
      const desiredAsUtc = Date.UTC(year, month - 1, day, hour, minute, second);
      let candidate = desiredAsUtc;
      for (let i = 0; i < 3; i += 1) {
        const offset = getTimeZoneOffsetMs(new Date(candidate), timeZone);
        candidate = desiredAsUtc - offset;
      }
      return candidate;
    }

    function formatDuration(ms) {
      const total = Math.max(0, Math.floor(ms / 1000));
      const days = Math.floor(total / 86400);
      const hours = Math.floor((total % 86400) / 3600);
      const minutes = Math.floor((total % 3600) / 60);
      const seconds = total % 60;
      if (days > 0) return `${days}d ${hours}h ${minutes}m ${seconds}s`;
      return `${hours}h ${minutes}m ${seconds}s`;
    }

    function updateTournamentCountdown() {
      const now = new Date();
      const berlin = getBerlinNowParts(now);
      const nowMs = now.getTime();
      const gameCfg = GAME_CONFIG[state.selectedGame] || GAME_CONFIG.mk8d;

      const isGameDay = berlin.weekday === gameCfg.weekday;
      const afterStart = berlin.hour > gameCfg.startHour || (berlin.hour === gameCfg.startHour && berlin.minute >= gameCfg.startMinute);
      const beforeEnd = berlin.hour < gameCfg.endHour || (berlin.hour === gameCfg.endHour && berlin.minute < gameCfg.endMinute);

      if (isGameDay && afterStart && beforeEnd) {
        const endMs = zonedDateTimeToUtcMs(berlin.year, berlin.month, berlin.day, gameCfg.endHour, gameCfg.endMinute, 0, "Europe/Berlin");
        const remaining = formatDuration(endMs - nowMs);
        el.countdownBanner.textContent = `${gameCfg.label} Turnier-Time ¬∑ Rest: ${remaining}`;
        return;
      }

      let daysUntilGameDay = 0;
      if (berlin.weekday < gameCfg.weekday) {
        daysUntilGameDay = gameCfg.weekday - berlin.weekday;
      } else if (berlin.weekday === gameCfg.weekday) {
        daysUntilGameDay = afterStart ? 7 : 0;
      } else {
        daysUntilGameDay = 7 - (berlin.weekday - gameCfg.weekday);
      }

      const targetDate = addDaysUtc(berlin.year, berlin.month, berlin.day, daysUntilGameDay);
      const targetMs = zonedDateTimeToUtcMs(targetDate.year, targetDate.month, targetDate.day, gameCfg.startHour, gameCfg.startMinute, 0, "Europe/Berlin");
      const countdown = formatDuration(targetMs - nowMs);
      const dayText = gameCfg.weekday === 7 ? "Sonntag" : "Mittwoch";
      const hh = String(gameCfg.startHour).padStart(2, "0");
      const mm = String(gameCfg.startMinute).padStart(2, "0");
      el.countdownBanner.textContent = `N√§chstes ${gameCfg.label}: ${dayText} ${hh}:${mm} (Berlin) ¬∑ in ${countdown}`;
    }

    function getISOWeek(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const day = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - day);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    function characterMetaFor(characterName) {
      return CHARACTER_META[normalizeCharacter(characterName)] || null;
    }

    function resolveCharacter(name, aliases, explicitCharacter) {
      return explicitCharacter || "";
    }

    async function fetchJson(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error("request failed");
      return response.json();
    }

    async function tryMarioWikiThumbnail(title) {
      const url = `https://www.mariowiki.com/api.php?action=query&origin=*&format=json&prop=pageimages&piprop=thumbnail&pithumbsize=128&titles=${encodeURIComponent(title)}`;
      const json = await fetchJson(url);
      const pages = json?.query?.pages || {};
      for (const page of Object.values(pages)) {
        if (page?.thumbnail?.source) return page.thumbnail.source;
      }
      return null;
    }

    async function searchMarioWikiTitle(term) {
      const searchUrl = `https://www.mariowiki.com/api.php?action=opensearch&origin=*&limit=1&search=${encodeURIComponent(term)}`;
      const search = await fetchJson(searchUrl);
      return Array.isArray(search?.[1]) ? (search[1][0] || null) : null;
    }

    function titleFromMarioWikiUrl(urlValue) {
      try {
        const url = new URL(urlValue);
        if (!/mariowiki\.com$/i.test(url.hostname)) return null;
        const raw = url.pathname.replace(/^\/+/, "");
        if (!raw) return null;
        return decodeURIComponent(raw.replace(/_/g, " "));
      } catch {
        return null;
      }
    }

    async function fetchAvatar(seedOrCharacterOrName) {
      const key = normalizeCharacter(seedOrCharacterOrName);
      if (!key) return null;
      if (state.avatarCache.has(key)) return state.avatarCache.get(key);

      const titles = [];
      const asWikiTitle = titleFromMarioWikiUrl(seedOrCharacterOrName);
      if (asWikiTitle) titles.push(asWikiTitle);

      const meta = characterMetaFor(seedOrCharacterOrName);
      if (meta?.page) titles.push(meta.page);

      titles.push(String(seedOrCharacterOrName || ""));
      titles.push(`${seedOrCharacterOrName} (character)`);

      try {
        for (const t of titles.filter(Boolean)) {
          const image = await tryMarioWikiThumbnail(t);
          if (image) {
            state.avatarCache.set(key, image);
            return image;
          }
        }

        const searchTitle = await searchMarioWikiTitle(String(seedOrCharacterOrName || ""));
        if (searchTitle) {
          const image = await tryMarioWikiThumbnail(searchTitle);
          if (image) {
            state.avatarCache.set(key, image);
            return image;
          }
        }

        state.avatarCache.set(key, null);
        return null;
      } catch {
        state.avatarCache.set(key, null);
        return null;
      }
    }

    function parseTournamentYear(row, fallbackYear) {
      return parseYear(row.datum || row.date || row.jahr || row.year) || fallbackYear;
    }

    function usernameFromName(name, fallback) {
      const base = String(name || fallback || "").trim();
      if (!base) return "";
      return normalizeKey(base).replace(/\s+/g, "_");
    }

    function normalizedCells(row) {
      const out = {};
      Object.entries(row || {}).forEach(([k, v]) => {
        out[normalizeKey(k)] = String(v ?? "");
      });
      return out;
    }

    function scoreForPlayer(tournament, player) {
      const keys = [player.id, ...(player.scoreKeys || [])];
      for (const key of keys) {
        const value = tournament.cells[normalizeKey(key)];
        if (typeof value !== "undefined" && String(value).trim() !== "") return toNumber(value);
      }
      return 0;
    }

    function hasScoreEntry(tournament, player) {
      const keys = [player.id, ...(player.scoreKeys || [])];
      return keys.some((key) => {
        const value = tournament.cells[normalizeKey(key)];
        return typeof value !== "undefined" && String(value).trim() !== "";
      });
    }

    function buildData(playerRows, tournamentRows, targetYear, targetGame) {
      const now = new Date();
      const currentWeek = getISOWeek(now);
      const currentYear = now.getFullYear();
      if (!playerRows.length || !tournamentRows.length) {
        return { players: [], weekColumns: [], currentWeek, currentYear };
      }

      const tournaments = tournamentRows
        .map((row, idx) => {
          const id = row.turnier_id || row.turnierId || `T${String(idx + 1).padStart(3, "0")}`;
          const date = row.datum || row.date || "";
          const week = parseIsoWeekFromDate(date) ?? parseKw(row.kw || row.KW || row.woche || row.Woche);
          const year = parseTournamentYear(row, currentYear);
          const game = normalizeGameKey(row.spiel || row.game || row.modus_spiel || "mk8d");
          const cells = normalizedCells(row);
          return { id, date, week, year, game, row, cells };
        })
        .filter((t) => {
          if (t.game !== targetGame) return false;
          if (t.week === null || t.year !== targetYear) return false;
          if (targetYear === currentYear) return t.week <= currentWeek;
          return true;
        })
        .sort((a, b) => a.week - b.week || String(a.date).localeCompare(String(b.date)));

      const playerBase = playerRows.map((row, idx) => {
        const username = String(row.username || "").trim() || usernameFromName(row.name || row.spieler, `spieler_${idx + 1}`);
        const id = normalizeKey(username);
        const name = row.name || row.spieler || `Spieler ${idx + 1}`;
        const aliases = String(row.alt_names || row.alias || "").split("|").map((x) => x.trim()).filter(Boolean);
        const explicitCharacter = String(row.charakter || row.character || "").trim();
        const character = resolveCharacter(name, aliases, explicitCharacter);
        const meta = characterMetaFor(character);
        const csvColor = String(row.farbe_hex || "").trim();
        const color = csvColor || meta?.color || COLOR_POOL[idx % COLOR_POOL.length];
        const avatarSeed = String(row.charakter_bild_url || "").trim();
        const faceAnchor = meta?.faceAnchor || "center";
        const scoreKeys = [];
        return { id, name, username, aliases, character, color, avatarSeed, faceAnchor, scoreKeys };
      });

      const candidateTournaments = tournaments.filter((t) => {
        return playerBase.some((p) => hasScoreEntry(t, p));
      });

      const withScores = playerBase.map((p) => {
        const weekScores = candidateTournaments.map((t) => scoreForPlayer(t, p));
        const total = weekScores.reduce((a, b) => a + b, 0);
        return { ...p, weekScores, total, avatar: null };
      }).filter((p) => p.total > 0);

      const activeIds = new Set(withScores.map((p) => p.id));
      const finalTournaments = candidateTournaments.filter((t) => {
        for (const player of withScores) {
          if (!activeIds.has(player.id)) continue;
          if (hasScoreEntry(t, player)) return true;
        }
        return false;
      });

      const players = withScores.map((p) => {
        const weekScores = finalTournaments.map((t) => scoreForPlayer(t, p));
        const total = weekScores.reduce((a, b) => a + b, 0);
        return { ...p, weekScores, total };
      });

      const weekColumns = finalTournaments.map((t, idx) => ({
        index: idx,
        week: t.week,
        year: t.year,
        date: t.date,
        turnierId: t.id
      }));

      return { players, weekColumns, currentWeek, currentYear };
    }

    function yearsForGame(gameKey) {
      const nowYear = new Date().getFullYear();
      return Array.from(
        new Set(
          state.allTournamentRows
            .filter((row) => normalizeGameKey(row.spiel || row.game || row.modus_spiel || "mk8d") === gameKey)
            .map((row) => parseTournamentYear(row, nowYear))
            .filter(Boolean)
        )
      ).sort((a, b) => a - b);
    }

    function populateYearSelect() {
      el.yearSelect.innerHTML = "";
      state.availableYears
        .slice()
        .sort((a, b) => b - a)
        .forEach((year) => {
          const option = document.createElement("option");
          option.value = String(year);
          option.textContent = String(year);
          if (year === state.selectedYear) option.selected = true;
          el.yearSelect.appendChild(option);
        });
      el.yearSelect.disabled = state.availableYears.length <= 1;
    }

    function applyYear(year) {
      const { players, weekColumns, currentWeek, currentYear } = buildData(state.allPlayerRows, state.allTournamentRows, year, state.selectedGame);
      state.players = players;
      state.weekColumns = weekColumns;
      state.selectedYear = year;
      el.yearSelect.value = String(year);

      if (!state.players.length || !state.weekColumns.length) {
        throw new Error(`Keine g√ºltigen Turnierdaten f√ºr ${year} gefunden.`);
      }

      state.selectedWeekIndex = state.weekColumns.length - 1;
      el.slider.min = "0";
      el.slider.max = String(state.weekColumns.length - 1);
      el.slider.value = String(state.selectedWeekIndex);

      const firstWeek = state.weekColumns[0].week;
      const lastWeek = state.weekColumns[state.weekColumns.length - 1].week;
      const yearLabel = state.weekColumns[0].year || year;
      const currentYearSuffix = year === currentYear ? ` ¬∑ Aktuelle KW ${currentWeek}` : "";
      const gameLabel = GAME_CONFIG[state.selectedGame]?.label || state.selectedGame;
      el.meta.textContent = `${gameLabel} ¬∑ ${state.players.length} aktive ¬∑ ${state.weekColumns.length} Turniere ¬∑ ${yearLabel} KW ${firstWeek}-${lastWeek}${currentYearSuffix}`;
    }

    function clearVisuals() {
      el.leaderboardBody.innerHTML = "";
      clearSvg(el.positionsChart);
      clearSvg(el.pointsChart);
      clearSvg(el.momentumChart);
      el.lineLegend.innerHTML = "";
    }

    function setGameUi(gameKey) {
      const cfg = GAME_CONFIG[gameKey] || GAME_CONFIG.mk8d;
      document.body.classList.remove("game-mk8d", "game-mkworld");
      document.body.classList.add(cfg.bodyClass);
      el.heroTitle.textContent = cfg.title;
      el.gameMk8dBtn.setAttribute("aria-pressed", gameKey === "mk8d" ? "true" : "false");
      el.gameMkworldBtn.setAttribute("aria-pressed", gameKey === "mkworld" ? "true" : "false");
    }

    function applyGameSelection(gameKey) {
      state.selectedGame = gameKey;
      setGameUi(gameKey);

      state.availableYears = yearsForGame(gameKey);
      populateYearSelect();

      if (!state.availableYears.length) {
        clearVisuals();
        showError(`Keine Turnierdaten f√ºr ${GAME_CONFIG[gameKey]?.label || gameKey} vorhanden.`);
        el.meta.textContent = "Keine Daten";
        updateTournamentCountdown();
        return;
      }

      el.error.hidden = true;
      state.selectedYear = state.availableYears.includes(state.selectedYear)
        ? state.selectedYear
        : state.availableYears[state.availableYears.length - 1];

      applyYear(state.selectedYear);
      render();
      enrichAvatars();
      updateTournamentCountdown();
    }

    function cumulativeAt(player, weekIndex) {
      return player.weekScores.slice(0, weekIndex + 1).reduce((a, b) => a + b, 0);
    }

    function rankByWeek(weekIndex) {
      const ranked = state.players
        .map((p) => ({ ...p, pointsWeek: p.weekScores[weekIndex] || 0, pointsTotal: cumulativeAt(p, weekIndex) }))
        .sort((a, b) => b.pointsTotal - a.pointsTotal || b.pointsWeek - a.pointsWeek || a.name.localeCompare(b.name));
      return ranked.map((p, idx) => ({ ...p, rank: idx + 1 }));
    }

    function trendClass(delta) {
      if (delta > 0) return "delta-up";
      if (delta < 0) return "delta-down";
      return "delta-flat";
    }

    function clearSvg(svg) { while (svg.firstChild) svg.removeChild(svg.firstChild); }

    function svgNode(name, attrs = {}) {
      const n = document.createElementNS("http://www.w3.org/2000/svg", name);
      Object.entries(attrs).forEach(([k, v]) => n.setAttribute(k, String(v)));
      return n;
    }

    function displayName(player) {
      const user = String(player.username || "").trim();
      return user || player.name;
    }

    function showLineTooltip(player, x, y) {
      el.lineTooltipImg.src = player.avatar || FALLBACK_AVATAR;
      const label = displayName(player);
      el.lineTooltipName.textContent = player.character ? `${label} ¬∑ ${player.character}` : label;
      el.lineTooltip.hidden = false;
      el.lineTooltip.style.left = `${x + 10}px`;
      el.lineTooltip.style.top = `${y + 10}px`;
    }

    function hideLineTooltip() { el.lineTooltip.hidden = true; }

    function renderTable() {
      const weekIndex = state.selectedWeekIndex;
      const current = rankByWeek(weekIndex);
      const prevMap = new Map();
      if (weekIndex > 0) rankByWeek(weekIndex - 1).forEach((p) => prevMap.set(p.id, p.rank));

      el.leaderboardBody.innerHTML = "";
      current.forEach((p) => {
        const prevRank = prevMap.get(p.id) ?? p.rank;
        const delta = prevRank - p.rank;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="rank">${p.rank}</td>
          <td>
            <div class="player">
              <img
                class="avatar"
                src="${p.avatar || FALLBACK_AVATAR}"
                alt="${p.name}"
                loading="lazy"
                style="border-color:${p.color}; box-shadow:0 0 0 2px ${p.color}; object-position:${faceObjectPosition(p.faceAnchor)};"
              />
              <div>
                <div>${displayName(p)}</div>
                <small class="player-meta">${p.name}</small>
              </div>
            </div>
          </td>
          <td class="num">${p.pointsWeek.toLocaleString("de-DE")}</td>
          <td class="num">${p.pointsTotal.toLocaleString("de-DE")}</td>
          <td class="num ${trendClass(delta)}">${delta > 0 ? "+" : ""}${delta}</td>
        `;
        el.leaderboardBody.appendChild(tr);
      });
    }

    function renderPositionsChart() {
      const svg = el.positionsChart;
      clearSvg(svg);
      const weekCount = state.weekColumns.length;
      const players = state.players;
      if (!weekCount || !players.length) return;

      const width = 1080;
      const height = 420;
      const m = { top: 20, right: 18, bottom: 44, left: 44 };
      const iw = width - m.left - m.right;
      const ih = height - m.top - m.bottom;
      const x = (i) => m.left + iw * (i / Math.max(1, weekCount - 1));
      const y = (rank) => m.top + ih * ((rank - 1) / Math.max(1, players.length - 1));

      const rankMap = new Map();
      for (let i = 0; i < weekCount; i++) rankMap.set(i, rankByWeek(i));

      for (let r = 1; r <= players.length; r++) {
        svg.appendChild(svgNode("line", { x1: m.left, y1: y(r), x2: width - m.right, y2: y(r), stroke: "#e6edff", "stroke-width": 1 }));
      }

      for (let i = 0; i < weekCount; i++) {
        svg.appendChild(svgNode("line", { x1: x(i), y1: m.top, x2: x(i), y2: height - m.bottom, stroke: i === state.selectedWeekIndex ? "#8c4dff" : "#eef3ff", "stroke-width": i === state.selectedWeekIndex ? 2 : 1 }));
      }

      const lineNodes = new Map();
      const playersById = new Map(players.map((p) => [p.id, p]));

      function setActivePlayer(id, evt) {
        state.activePlayerId = id;
        lineNodes.forEach((node, nodeId) => {
          const active = nodeId === id;
          node.path.setAttribute("opacity", active ? "1" : "0.2");
          node.path.setAttribute("stroke-width", active ? "4.8" : "2.4");
          node.dot.setAttribute("r", active ? "5.5" : "3.4");
          node.dot.setAttribute("opacity", active ? "1" : "0.35");
        });
        const player = playersById.get(id);
        if (player && evt) showLineTooltip(player, evt.clientX, evt.clientY);
      }

      function clearActivePlayer() {
        state.activePlayerId = null;
        lineNodes.forEach((node) => {
          node.path.setAttribute("opacity", "0.95");
          node.path.setAttribute("stroke-width", "2.4");
          node.dot.setAttribute("r", "3.4");
          node.dot.setAttribute("opacity", "0.95");
        });
        hideLineTooltip();
      }

      players.forEach((p) => {
        const pts = [];
        for (let i = 0; i < weekCount; i++) {
          const rank = rankMap.get(i).find((x) => x.id === p.id)?.rank || players.length;
          pts.push([x(i), y(rank)]);
        }

        const d = pts.map((pt, idx) => `${idx ? "L" : "M"}${pt[0]},${pt[1]}`).join(" ");
        const path = svgNode("path", { d, fill: "none", stroke: p.color, "stroke-width": 2.4, "stroke-linecap": "round", opacity: 0.95 });
        svg.appendChild(path);

        const hoverPath = svgNode("path", { d, fill: "none", stroke: "transparent", "stroke-width": 14, "stroke-linecap": "round", style: "cursor:pointer" });
        hoverPath.addEventListener("mouseenter", (evt) => setActivePlayer(p.id, evt));
        hoverPath.addEventListener("mousemove", (evt) => {
          if (state.activePlayerId === p.id) showLineTooltip(p, evt.clientX, evt.clientY);
        });
        hoverPath.addEventListener("mouseleave", clearActivePlayer);
        svg.appendChild(hoverPath);

        const last = pts[state.selectedWeekIndex] || pts[pts.length - 1];
        const dot = svgNode("circle", { cx: last[0], cy: last[1], r: 3.4, fill: p.color, stroke: "#fff", "stroke-width": 1.3, opacity: 0.95 });
        svg.appendChild(dot);
        lineNodes.set(p.id, { path, dot });
      });

      svg.addEventListener("mouseleave", hideLineTooltip);
      svg.appendChild(svgNode("rect", { x: m.left, y: m.top, width: iw, height: ih, fill: "none", stroke: "#ced8ff", "stroke-width": 1 }));

      const step = Math.max(1, Math.floor(weekCount / 12));
      for (let i = 0; i < weekCount; i += step) {
        svg.appendChild(svgNode("text", { x: x(i), y: height - m.bottom + 18, "font-size": 12, "text-anchor": "middle", fill: "#45589f" })).textContent = `W${state.weekColumns[i].week}`;
      }

      for (let r = 1; r <= Math.min(players.length, 12); r++) {
        svg.appendChild(svgNode("text", { x: m.left - 10, y: y(r) + 4, "font-size": 12, "text-anchor": "end", fill: "#45589f" })).textContent = String(r);
      }

      el.lineLegend.innerHTML = "";
      players.slice(0, 14).forEach((p) => {
        const item = document.createElement("span");
        item.className = "legend-item";
        item.innerHTML = `<span class="legend-dot" style="background:${p.color}"></span>${displayName(p)}`;
        item.addEventListener("mouseenter", (evt) => setActivePlayer(p.id, evt));
        item.addEventListener("mousemove", (evt) => {
          if (state.activePlayerId === p.id) showLineTooltip(p, evt.clientX, evt.clientY);
        });
        item.addEventListener("mouseleave", clearActivePlayer);
        el.lineLegend.appendChild(item);
      });
    }

    function renderPointsChart() {
      const svg = el.pointsChart;
      clearSvg(svg);
      const ranked = rankByWeek(state.selectedWeekIndex);
      const top = ranked.slice(0, 10);
      if (!top.length) return;

      const width = 520;
      const height = 360;
      const isMobile = window.matchMedia("(max-width: 640px)").matches;
      const m = isMobile
        ? { top: 12, right: 10, bottom: 24, left: 132 }
        : { top: 12, right: 12, bottom: 28, left: 180 };
      const iw = width - m.left - m.right;
      const rowH = (height - m.top - m.bottom) / top.length;
      const max = Math.max(1, ...top.map((p) => p.pointsTotal));
      const labelSize = isMobile ? 11 : 12;

      top.forEach((p, i) => {
        const y = m.top + i * rowH + 4;
        const w = (p.pointsTotal / max) * iw;
        const valueX = Math.min(m.left + w + 6, width - 8);
        const valueAnchor = valueX >= width - 8 ? "end" : "start";
        svg.appendChild(svgNode("rect", { x: m.left, y, width: w, height: rowH - 8, rx: 5, fill: p.color, opacity: 0.9 }));
        svg.appendChild(svgNode("text", { x: m.left - 6, y: y + (rowH - 8) / 2 + 4, "font-size": labelSize, "text-anchor": "end", fill: "#364c94" })).textContent = `${p.rank}. ${displayName(p)}`;
        svg.appendChild(svgNode("text", { x: valueX, y: y + (rowH - 8) / 2 + 4, "font-size": labelSize, "text-anchor": valueAnchor, fill: "#364c94" })).textContent = `${p.pointsTotal}`;
      });
    }

    function renderMomentumChart() {
      const svg = el.momentumChart;
      clearSvg(svg);
      const current = state.selectedWeekIndex;
      const ranked = rankByWeek(current);
      const top = ranked.slice(0, 10).map((p) => {
        const start = Math.max(0, current - 2);
        const recent = p.weekScores.slice(start, current + 1).reduce((a, b) => a + b, 0);
        return { ...p, recent };
      }).sort((a, b) => b.recent - a.recent);
      if (!top.length) return;

      const width = 520;
      const height = 360;
      const isMobile = window.matchMedia("(max-width: 640px)").matches;
      const m = isMobile
        ? { top: 12, right: 10, bottom: 24, left: 132 }
        : { top: 12, right: 12, bottom: 28, left: 180 };
      const iw = width - m.left - m.right;
      const rowH = (height - m.top - m.bottom) / top.length;
      const max = Math.max(1, ...top.map((p) => p.recent));
      const labelSize = isMobile ? 11 : 12;

      top.forEach((p, i) => {
        const y = m.top + i * rowH + 4;
        const w = (p.recent / max) * iw;
        const fill = i % 2 === 0 ? "#2f57ff" : "#8c4dff";
        const valueX = Math.min(m.left + w + 6, width - 8);
        const valueAnchor = valueX >= width - 8 ? "end" : "start";
        svg.appendChild(svgNode("rect", { x: m.left, y, width: w, height: rowH - 8, rx: 5, fill, opacity: 0.88 }));
        svg.appendChild(svgNode("text", { x: m.left - 6, y: y + (rowH - 8) / 2 + 4, "font-size": labelSize, "text-anchor": "end", fill: "#364c94" })).textContent = displayName(p);
        svg.appendChild(svgNode("text", { x: valueX, y: y + (rowH - 8) / 2 + 4, "font-size": labelSize, "text-anchor": valueAnchor, fill: "#364c94" })).textContent = `${p.recent}`;
      });
    }

    function render() {
      if (!state.players.length || !state.weekColumns.length) return;
      const weekData = state.weekColumns[state.selectedWeekIndex];
      const weekNo = weekData?.week ?? 1;
      el.weekLabel.textContent = `${state.selectedYear} ¬∑ W${weekNo}`;
      renderTable();
      renderPositionsChart();
      renderPointsChart();
      renderMomentumChart();
    }

    async function enrichAvatars() {
      const tasks = state.players.map(async (player) => {
        const image = await fetchAvatar(player.avatarSeed || player.character || player.name);
        if (image) player.avatar = image;
      });
      await Promise.all(tasks);
      render();
    }

    function showError(message) {
      el.error.hidden = false;
      el.error.textContent = message;
    }

    async function init() {
      try {
        const [playersResponse, tournamentsResponse] = await Promise.all([
          fetch(CONFIG.playersCsvFile, { cache: "no-store" }),
          fetch(CONFIG.tournamentsCsvFile, { cache: "no-store" })
        ]);

        if (!playersResponse.ok) throw new Error(`spieler.csv konnte nicht geladen werden (${playersResponse.status})`);
        if (!tournamentsResponse.ok) throw new Error(`turniere.csv konnte nicht geladen werden (${tournamentsResponse.status})`);

        const [playersText, tournamentsText] = await Promise.all([
          playersResponse.text(),
          tournamentsResponse.text()
        ]);

        const playerRows = parseDelimited(playersText);
        const tournamentRows = parseDelimited(tournamentsText);
        state.allPlayerRows = playerRows;
        state.allTournamentRows = tournamentRows;

        el.slider.addEventListener("input", () => {
          state.selectedWeekIndex = Number(el.slider.value);
          render();
        });

        el.yearSelect.addEventListener("change", () => {
          const selected = Number(el.yearSelect.value);
          if (!Number.isFinite(selected)) return;
          applyYear(selected);
          render();
          enrichAvatars();
        });

        el.gameMk8dBtn.addEventListener("click", () => applyGameSelection("mk8d"));
        el.gameMkworldBtn.addEventListener("click", () => applyGameSelection("mkworld"));

        const detectedGames = Array.from(
          new Set(tournamentRows.map((row) => normalizeGameKey(row.spiel || row.game || row.modus_spiel || "mk8d")))
        );
        state.availableGames = detectedGames;
        state.selectedGame = detectedGames.includes("mk8d") ? "mk8d" : (detectedGames[0] || "mk8d");
        applyGameSelection(state.selectedGame);

        setInterval(updateTournamentCountdown, 1000);
      } catch (err) {
        showError(err instanceof Error ? err.message : "Unbekannter Fehler beim Laden der Daten.");
        el.meta.textContent = "Fehler";
      }
    }

    init();
  </script>
</body>
</html>
